"""
Agent API Pydantic models
"""

from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field

from .common import ErrorInfo, LLMConfig, NotebookContext, ToolCall


# ============ Plan Request/Response ============


class PlanStep(BaseModel):
    """Single step in an execution plan"""

    stepNumber: int = Field(description="Step number (1-based)")
    description: str = Field(description="Human-readable step description")
    toolCalls: List[ToolCall] = Field(
        default_factory=list, description="Tools to execute in this step"
    )
    expectedOutput: Optional[str] = Field(
        default=None, description="Expected output description"
    )


class ExecutionPlan(BaseModel):
    """Execution plan generated by the agent"""

    goal: str = Field(description="Overall goal description")
    totalSteps: int = Field(description="Total number of steps")
    steps: List[PlanStep] = Field(description="Ordered list of execution steps")


class PlanRequest(BaseModel):
    """Request body for plan generation"""

    request: str = Field(description="User's natural language request")
    notebookContext: NotebookContext = Field(
        default_factory=NotebookContext, description="Current notebook state"
    )
    llmConfig: Optional[LLMConfig] = Field(
        default=None, description="LLM configuration with API keys (client-provided)"
    )


class PlanResponse(BaseModel):
    """Response body for plan generation"""

    plan: ExecutionPlan = Field(description="Generated execution plan")
    reasoning: str = Field(default="", description="Agent's reasoning explanation")


# ============ Refine Request/Response ============


class RefineRequest(BaseModel):
    """Request body for code refinement"""

    step: Dict[str, Any] = Field(description="Current step being refined")
    error: ErrorInfo = Field(description="Error that triggered refinement")
    attempt: int = Field(default=1, description="Current attempt number")
    previousCode: Optional[str] = Field(
        default=None, description="Previously executed code"
    )
    llmConfig: Optional[LLMConfig] = Field(
        default=None, description="LLM configuration with API keys (client-provided)"
    )


class RefineResponse(BaseModel):
    """Response body for code refinement"""

    toolCalls: List[ToolCall] = Field(description="Refined tool calls")
    reasoning: str = Field(default="", description="Refinement reasoning")


# ============ Replan Request/Response ============


class ReplanRequest(BaseModel):
    """Request body for replanning"""

    originalPlan: ExecutionPlan = Field(description="Original execution plan")
    currentStepIndex: int = Field(description="Index of the failed step")
    error: ErrorInfo = Field(description="Error that triggered replan")
    executionHistory: List[Dict[str, Any]] = Field(
        default_factory=list, description="History of executed steps"
    )


class ReplanResponse(BaseModel):
    """Response body for replanning"""

    decision: str = Field(
        description="Replan decision type (refine/insert_steps/replace_step/replan_remaining)"
    )
    analysis: Dict[str, Any] = Field(description="Error analysis details")
    reasoning: str = Field(default="", description="Replan reasoning")
    changes: Dict[str, Any] = Field(
        default_factory=dict, description="Proposed changes"
    )


# ============ Reflect Request/Response ============


class ReflectRequest(BaseModel):
    """Request body for reflection on execution"""

    plan: ExecutionPlan = Field(description="Executed plan")
    executionResults: List[Dict[str, Any]] = Field(
        description="Results from each step"
    )
    userGoal: str = Field(description="Original user goal")


class ReflectResponse(BaseModel):
    """Response body for reflection"""

    goalAchieved: bool = Field(description="Whether the goal was achieved")
    summary: str = Field(description="Summary of execution")
    suggestions: List[str] = Field(
        default_factory=list, description="Suggestions for improvement"
    )


# ============ State Verification ============


class VerifyStateRequest(BaseModel):
    """Request body for state verification"""

    stepIndex: int = Field(description="Step index to verify")
    expectedChanges: Dict[str, Any] = Field(
        description="Expected state changes from the step"
    )
    actualOutput: str = Field(description="Actual output from execution")
    executionResult: Dict[str, Any] = Field(description="Full execution result")


class VerifyStateResponse(BaseModel):
    """Response body for state verification"""

    verified: bool = Field(description="Whether state matches expectations")
    discrepancies: List[str] = Field(
        default_factory=list, description="List of discrepancies found"
    )
    confidence: float = Field(
        default=0.0, description="Confidence score (0.0-1.0)"
    )


# ============ Report Execution ============


class ReportExecutionRequest(BaseModel):
    """Request body for reporting tool execution results"""

    stepId: str = Field(description="Step identifier")
    result: Dict[str, Any] = Field(description="Execution result details")


class ReportExecutionResponse(BaseModel):
    """Response body for execution report"""

    acknowledged: bool = Field(default=True)
    nextAction: Optional[str] = Field(
        default=None, description="Suggested next action"
    )
